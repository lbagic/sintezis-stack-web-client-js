// @generated by protoc-gen-es v0.1.1 with parameter "target=js+dts"
// @generated from file proto/commons/flow_common.proto (package elude.proto, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3} from "@bufbuild/protobuf";
import type {BookingClassEnum, GDSEnum, HotelSearchTypeEnum, LocationTypeEnum, PaymentProvidersEnum, PriorityEnum, TravellerTypeEnum} from "./enum_pb.js";
import type {Timestamp} from "./timestamp_pb.js";
import type {Coordinates} from "./coordinates_pb.js";
import type {Airline} from "../models/airline_pb.js";
import type {Airport, Property} from "../models/city_pb.js";
import type {LocationMetadata} from "./metadata_pb.js";

/**
 * User specified budget
 *
 * @generated from message elude.proto.Budget
 */
export declare class Budget extends Message<Budget> {
  /**
   * Min price for search.
   *
   * @generated from field: int32 min_price = 1;
   */
  minPrice: number;

  /**
   * Max price for search.
   *
   * @generated from field: int32 max_price = 2;
   */
  maxPrice: number;

  /**
   * Currently not used.
   *
   * @generated from field: int32 absolute_max_price = 3;
   */
  absoluteMaxPrice: number;

  /**
   * 3 letter currency code (eg, USD, EUR, HRK)
   *
   * @generated from field: string currency = 4;
   */
  currency: string;

  constructor(data?: PartialMessage<Budget>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.Budget";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Budget;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Budget;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Budget;

  static equals(a: Budget | PlainMessage<Budget> | undefined, b: Budget | PlainMessage<Budget> | undefined): boolean;
}

/**
 * Date used for departure date and return date pairs
 *
 * @generated from message elude.proto.Date
 */
export declare class Date extends Message<Date> {
  /**
   * Year
   *
   * @generated from field: int32 year = 1;
   */
  year: number;

  /**
   * Month
   *
   * @generated from field: int32 month = 2;
   */
  month: number;

  /**
   * Day
   *
   * @generated from field: int32 day = 3;
   */
  day: number;

  /**
   * TZ dataformat, example: Europe/Zagreb; https://stackoverflow.com/questions/40120056/get-a-list-of-valid-time-zones-in-go
   *
   * @generated from field: string timezone = 4;
   */
  timezone: string;

  constructor(data?: PartialMessage<Date>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.Date";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Date;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Date;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Date;

  static equals(a: Date | PlainMessage<Date> | undefined, b: Date | PlainMessage<Date> | undefined): boolean;
}

/**
 * Contains departure and return dates
 *
 * @generated from message elude.proto.Dates
 */
export declare class Dates extends Message<Dates> {
  /**
   * Trip departure date
   *
   * @generated from field: elude.proto.Date departure = 1;
   */
  departure?: Date;

  /**
   * Trip return date
   *
   * @generated from field: elude.proto.Date return = 2;
   */
  return?: Date;

  constructor(data?: PartialMessage<Dates>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.Dates";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Dates;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Dates;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Dates;

  static equals(a: Dates | PlainMessage<Dates> | undefined, b: Dates | PlainMessage<Dates> | undefined): boolean;
}

/**
 * GDS provider message to be used only in GDS rpc calls
 *
 * @generated from message elude.proto.GDSBackend
 */
export declare class GDSBackend extends Message<GDSBackend> {
  /**
   * Gds name (Amadeus/Travelport/Sabre)
   *
   * @generated from field: elude.proto.GDSEnum name = 1;
   */
  name: GDSEnum;

  /**
   * Priority number (1 is first)
   *
   * @generated from field: int32 priority = 2;
   */
  priority: number;

  /**
   * Timeout for gds in milliseconds. Can find it in request options.
   *
   * @generated from field: int32 timeout_ms = 3;
   */
  timeoutMs: number;

  constructor(data?: PartialMessage<GDSBackend>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSBackend";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSBackend;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSBackend;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSBackend;

  static equals(a: GDSBackend | PlainMessage<GDSBackend> | undefined, b: GDSBackend | PlainMessage<GDSBackend> | undefined): boolean;
}

/**
 * Payment provider message to be used only in GDS rpc calls
 *
 * @generated from message elude.proto.GDSPaymentProvider
 */
export declare class GDSPaymentProvider extends Message<GDSPaymentProvider> {
  /**
   * Payment provider name (Stripe/Paypal)
   *
   * @generated from field: elude.proto.PaymentProvidersEnum name = 1;
   */
  name: PaymentProvidersEnum;

  constructor(data?: PartialMessage<GDSPaymentProvider>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSPaymentProvider";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSPaymentProvider;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSPaymentProvider;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSPaymentProvider;

  static equals(a: GDSPaymentProvider | PlainMessage<GDSPaymentProvider> | undefined, b: GDSPaymentProvider | PlainMessage<GDSPaymentProvider> | undefined): boolean;
}

/**
 * Currently not used.
 *
 * @generated from message elude.proto.GDSOptions
 */
export declare class GDSOptions extends Message<GDSOptions> {
  /**
   * @generated from field: repeated elude.proto.GDSBackend air_backends = 1;
   */
  airBackends: GDSBackend[];

  /**
   * @generated from field: repeated elude.proto.GDSBackend hotel_backends = 2;
   */
  hotelBackends: GDSBackend[];

  constructor(data?: PartialMessage<GDSOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSOptions;

  static equals(a: GDSOptions | PlainMessage<GDSOptions> | undefined, b: GDSOptions | PlainMessage<GDSOptions> | undefined): boolean;
}

/**
 * Hotel message to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.GDSHotel
 */
export declare class GDSHotel extends Message<GDSHotel> {
  /**
   * Hotel id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Hotel name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Hotel description.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Hotel address.
   *
   * @generated from field: string address = 4;
   */
  address: string;

  /**
   * Hotel message. Not used in database.
   *
   * @generated from field: string message = 5;
   */
  message: string;

  /**
   * Hotel chain code. Not used in database
   *
   * @generated from field: string code = 6;
   */
  code: string;

  /**
   * Hotel chain name. Not used in database.
   *
   * @generated from field: string chain = 7;
   */
  chain: string;

  /**
   * Hotel rating. (10 is the highest)
   *
   * @generated from field: int32 rating = 8;
   */
  rating: number;

  /**
   * Hotel check in date time.
   *
   * @generated from field: elude.proto.Timestamp check_in_datetime = 9;
   */
  checkInDatetime?: Timestamp;

  /**
   * Hotel check out date time.
   *
   * @generated from field: elude.proto.Timestamp check_out_datetime = 10;
   */
  checkOutDatetime?: Timestamp;

  /**
   * Hotel longitude and latitude coordinates.
   *
   * @generated from field: elude.proto.Coordinates coordinates = 11;
   */
  coordinates?: Coordinates;

  /**
   * List of hotel telephones.
   *
   * @generated from field: repeated elude.proto.Telephone telephones = 12;
   */
  telephones: Telephone[];

  /**
   * List of hotel gds amenities.
   *
   * @generated from field: repeated elude.proto.GDSAmenity amenities = 13;
   */
  amenities: GDSAmenity[];

  /**
   * Hotel image urls.
   *
   * @generated from field: repeated string media = 14;
   */
  media: string[];

  /**
   * List of gds rooms.
   *
   * @generated from field: repeated elude.proto.GDSRoom rooms = 15;
   */
  rooms: GDSRoom[];

  /**
   * Gds hotel reservation.
   *
   * @generated from field: elude.proto.GDSBackend gds = 16;
   */
  gds?: GDSBackend;

  /**
   * Gds hotel reservation code
   *
   * @generated from field: string confirmation_code = 17;
   */
  confirmationCode: string;

  /**
   * Gds hotel rate source. Default is 100.
   *
   * @generated from field: string rate_source = 18;
   */
  rateSource: string;

  /**
   * Based on priority search. Default is 1 (medium).
   *
   * @generated from field: elude.proto.PriorityEnum priority = 19;
   */
  priority: PriorityEnum;

  /**
   * Type of hotel search types. (regular,timezone,priority).
   *
   * @generated from field: elude.proto.HotelSearchTypeEnum hotel_search_type = 20;
   */
  hotelSearchType: HotelSearchTypeEnum;

  constructor(data?: PartialMessage<GDSHotel>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSHotel";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSHotel;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSHotel;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSHotel;

  static equals(a: GDSHotel | PlainMessage<GDSHotel> | undefined, b: GDSHotel | PlainMessage<GDSHotel> | undefined): boolean;
}

/**
 * Telephone message to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.Telephone
 */
export declare class Telephone extends Message<Telephone> {
  /**
   * Telephone type (phone,tax).
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Telephone number.
   *
   * @generated from field: string number = 2;
   */
  number: string;

  constructor(data?: PartialMessage<Telephone>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.Telephone";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Telephone;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Telephone;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Telephone;

  static equals(a: Telephone | PlainMessage<Telephone> | undefined, b: Telephone | PlainMessage<Telephone> | undefined): boolean;
}

/**
 * Room message to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.GDSRoom
 */
export declare class GDSRoom extends Message<GDSRoom> {
  /**
   * Room id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Room name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Room description.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * If true room can be refunded.
   *
   * @generated from field: bool is_refundable = 4;
   */
  isRefundable: boolean;

  /**
   * If true breakfast is included with room reservation.
   *
   * @generated from field: bool breakfast_included = 5;
   */
  breakfastIncluded: boolean;

  /**
   * Room payment type. Currently default GUAR (Guaranteed Payment)
   *
   * @generated from field: string payment_type = 6;
   */
  paymentType: string;

  /**
   * List of gds amenities.
   *
   * @generated from field: repeated elude.proto.GDSAmenity amenities = 7;
   */
  amenities: GDSAmenity[];

  /**
   * Gds room price information.
   *
   * @generated from field: elude.proto.Price price = 8;
   */
  price?: Price;

  constructor(data?: PartialMessage<GDSRoom>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSRoom";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSRoom;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSRoom;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSRoom;

  static equals(a: GDSRoom | PlainMessage<GDSRoom> | undefined, b: GDSRoom | PlainMessage<GDSRoom> | undefined): boolean;
}

/**
 * Amenity message to be used only in GDS rpc calls. Amenities are stored in database and listed by amenity codes.
 *
 * @generated from message elude.proto.GDSAmenity
 */
export declare class GDSAmenity extends Message<GDSAmenity> {
  /**
   * Amenity name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Amenity url is not fetched from gds but built inside app.
   *
   * @generated from field: string image_url = 2;
   */
  imageUrl: string;

  /**
   * Gds amenity codes match amenity codes in database.
   *
   * @generated from field: int32 code = 3;
   */
  code: number;

  constructor(data?: PartialMessage<GDSAmenity>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSAmenity";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSAmenity;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSAmenity;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSAmenity;

  static equals(a: GDSAmenity | PlainMessage<GDSAmenity> | undefined, b: GDSAmenity | PlainMessage<GDSAmenity> | undefined): boolean;
}

/**
 * Contains info for a specific traveller, to be used only in GDS rpc calls
 *
 * @generated from message elude.proto.TravellerInfo
 */
export declare class TravellerInfo extends Message<TravellerInfo> {
  /**
   * Traveller id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Enum with traveller types
   *
   * Traveller price is based on traveller type.
   *
   * @generated from field: elude.proto.Price price = 3;
   */
  price?: Price;

  /**
   * Traveller type depends on age (adult/child/infant)
   *
   * @generated from field: elude.proto.TravellerTypeEnum traveller_type = 2;
   */
  travellerType: TravellerTypeEnum;

  /**
   * Used to ticket traveller.
   *
   * @generated from field: string ticket_number = 4;
   */
  ticketNumber: string;

  constructor(data?: PartialMessage<TravellerInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.TravellerInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TravellerInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TravellerInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TravellerInfo;

  static equals(a: TravellerInfo | PlainMessage<TravellerInfo> | undefined, b: TravellerInfo | PlainMessage<TravellerInfo> | undefined): boolean;
}

/**
 * Contains quantity for each traveller type, to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.Travellers
 */
export declare class Travellers extends Message<Travellers> {
  /**
   * Number of travellers age 12 and older.
   *
   * @generated from field: int32 adults = 1;
   */
  adults: number;

  /**
   * Number of travellers between ages 2 (included) and 12.
   *
   * @generated from field: int32 children = 2;
   */
  children: number;

  /**
   * Number of travellers younger than 2.
   *
   * @generated from field: int32 infants = 3;
   */
  infants: number;

  constructor(data?: PartialMessage<Travellers>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.Travellers";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Travellers;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Travellers;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Travellers;

  static equals(a: Travellers | PlainMessage<Travellers> | undefined, b: Travellers | PlainMessage<Travellers> | undefined): boolean;
}

/**
 * Flight message to be used only in GDS rpc calls. Contains all flight segments.
 *
 * @generated from message elude.proto.GDSFlight
 */
export declare class GDSFlight extends Message<GDSFlight> {
  /**
   * FLight duration in minutes. Calculated by adding all flight segment durations without breaks in between.
   *
   * @generated from field: string duration = 1;
   */
  duration: string;

  /**
   * List of all flight segments fetched from gds.
   *
   * @generated from field: repeated elude.proto.GDSFlightSegment flight_segments = 2;
   */
  flightSegments: GDSFlightSegment[];

  constructor(data?: PartialMessage<GDSFlight>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSFlight";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSFlight;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSFlight;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSFlight;

  static equals(a: GDSFlight | PlainMessage<GDSFlight> | undefined, b: GDSFlight | PlainMessage<GDSFlight> | undefined): boolean;
}

/**
 * Flight segment message to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.GDSFlightSegment
 */
export declare class GDSFlightSegment extends Message<GDSFlightSegment> {
  /**
   * Airline data for flight segment.
   *
   * @generated from field: elude.proto.Airline airline = 1;
   */
  airline?: Airline;

  /**
   * Duration of a specific flight segment in minutes.
   *
   * @generated from field: string duration = 2;
   */
  duration: string;

  /**
   * Carrier operating number (e.g. 3623)
   *
   * @generated from field: string flight_number = 3;
   */
  flightNumber: string;

  /**
   * Departure flight segment datetime timestamp. In database all timestamps are utc time.
   *
   * @generated from field: elude.proto.Timestamp departure_datetime = 4;
   */
  departureDatetime?: Timestamp;

  /**
   * Arrival flight segment datetime timestamp. In database all timestamps are utc time.
   *
   * @generated from field: elude.proto.Timestamp arrival_datetime = 5;
   */
  arrivalDatetime?: Timestamp;

  /**
   * Departure airport data for flight segment.
   *
   * @generated from field: elude.proto.Airport departure_airports = 6;
   */
  departureAirports?: Airport;

  /**
   * Arrival airport data for flight segment.
   *
   * @generated from field: elude.proto.Airport arrival_airports = 7;
   */
  arrivalAirports?: Airport;

  /**
   * Difference of departure location local time zone and utc.
   *
   * @generated from field: string departure_utc_offset = 8;
   */
  departureUtcOffset: string;

  /**
   * Difference of arrival location local time zone and utc.
   *
   * @generated from field: string arrival_utc_offset = 9;
   */
  arrivalUtcOffset: string;

  /**
   * Departure terminal.
   *
   * @generated from field: string departure_terminal = 10;
   */
  departureTerminal: string;

  /**
   * Arrival terminal.
   *
   * @generated from field: string arrival_terminal = 11;
   */
  arrivalTerminal: string;

  /**
   * Carrier airline iata code.
   *
   * @generated from field: string operating_airline_iata_code = 12;
   */
  operatingAirlineIataCode: string;

  constructor(data?: PartialMessage<GDSFlightSegment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSFlightSegment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSFlightSegment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSFlightSegment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSFlightSegment;

  static equals(a: GDSFlightSegment | PlainMessage<GDSFlightSegment> | undefined, b: GDSFlightSegment | PlainMessage<GDSFlightSegment> | undefined): boolean;
}

/**
 * Contains info on the flight options returned after a GDS flight search.
 *
 * @generated from message elude.proto.FlightOption
 */
export declare class FlightOption extends Message<FlightOption> {
  /**
   * Flight option id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Departure and return flight dates.
   *
   * @generated from field: elude.proto.Dates dates = 2;
   */
  dates?: Dates;

  /**
   * Departure flight data.
   *
   * @generated from field: elude.proto.GDSFlight departure_flight = 3;
   */
  departureFlight?: GDSFlight;

  /**
   * Arrival flight data.
   *
   * @generated from field: elude.proto.GDSFlight return_flight = 4;
   */
  returnFlight?: GDSFlight;

  /**
   * Total price information of flights.
   *
   * @generated from field: elude.proto.Price price = 5;
   */
  price?: Price;

  /**
   * List of traveller information of all travellers.
   *
   * @generated from field: repeated elude.proto.TravellerInfo traveller_info = 6;
   */
  travellerInfo: TravellerInfo[];

  /**
   * Gds for ticketing a flight.
   *
   * @generated from field: elude.proto.GDSBackend gds = 7;
   */
  gds?: GDSBackend;

  constructor(data?: PartialMessage<FlightOption>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.FlightOption";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlightOption;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlightOption;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlightOption;

  static equals(a: FlightOption | PlainMessage<FlightOption> | undefined, b: FlightOption | PlainMessage<FlightOption> | undefined): boolean;
}

/**
 * Hotel requirements when making a GDS hotel search.
 *
 * @generated from message elude.proto.HotelRequirements
 */
export declare class HotelRequirements extends Message<HotelRequirements> {
  /**
   * Used to filter hotels with minimal stars.
   *
   * @generated from field: int32 min_stars = 1;
   */
  minStars: number;

  /**
   * Used to check if hotel has amenities.
   *
   * @generated from field: bool amenities = 2;
   */
  amenities: boolean;

  /**
   * If true run search will skip hotel search.
   *
   * @generated from field: bool disable = 3;
   */
  disable: boolean;

  /**
   * Used to filter hotels with maximum stars.
   *
   * @generated from field: int32 max_stars = 4;
   */
  maxStars: number;

  constructor(data?: PartialMessage<HotelRequirements>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.HotelRequirements";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HotelRequirements;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HotelRequirements;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HotelRequirements;

  static equals(a: HotelRequirements | PlainMessage<HotelRequirements> | undefined, b: HotelRequirements | PlainMessage<HotelRequirements> | undefined): boolean;
}

/**
 * Air requirements when making a GDS flight search.
 *
 * @generated from message elude.proto.AirRequirements
 */
export declare class AirRequirements extends Message<AirRequirements> {
  /**
   * Booking class options (economy/business/first).
   *
   * @generated from field: elude.proto.BookingClassEnum booking_class = 1;
   */
  bookingClass: BookingClassEnum;

  /**
   * Disabled airlines are listed on launch darkly, fetched and mapped to this string.
   *
   * @generated from field: repeated string disabled_airlines = 2;
   */
  disabledAirlines: string[];

  /**
   * If true run search will skipp air search.
   *
   * @generated from field: bool disable = 3;
   */
  disable: boolean;

  constructor(data?: PartialMessage<AirRequirements>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.AirRequirements";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirRequirements;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirRequirements;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirRequirements;

  static equals(a: AirRequirements | PlainMessage<AirRequirements> | undefined, b: AirRequirements | PlainMessage<AirRequirements> | undefined): boolean;
}

/**
 * Location identifier is used to unite different location types in one structure.
 *
 * @generated from message elude.proto.LocationIdentifier
 */
export declare class LocationIdentifier extends Message<LocationIdentifier> {
  /**
   * Location identifier id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Location type (metropolitan area/city/airport/region/country/location)
   *
   * @generated from field: elude.proto.LocationTypeEnum location_type = 2;
   */
  locationType: LocationTypeEnum;

  /**
   * Location identifier iata code.
   *
   * @generated from field: string iata_code = 3;
   */
  iataCode: string;

  /**
   * Location identifier name.
   *
   * @generated from field: string location_name = 4;
   */
  locationName: string;

  /**
   * List of hotels with top priority. Found from property gds.
   *
   * @generated from field: repeated string priority_hotels_sabre = 5;
   */
  priorityHotelsSabre: string[];

  /**
   * Location identifier image url. Fetched from gds.
   *
   * @generated from field: string image_url = 6;
   */
  imageUrl: string;

  /**
   * Location identifier description.
   *
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   * If true sabre will find hotel address. If disabled sabre will find only iata code.
   *
   * @generated from field: bool hotel_address_search = 8;
   */
  hotelAddressSearch: boolean;

  /**
   * Contains location data. Depends on location type.
   *
   * @generated from field: elude.proto.LocationMetadata metadata = 9;
   */
  metadata?: LocationMetadata;

  /**
   * Id for shard location belongs to
   *
   * @generated from field: int32 shard_id = 10;
   */
  shardId: number;

  constructor(data?: PartialMessage<LocationIdentifier>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.LocationIdentifier";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationIdentifier;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationIdentifier;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationIdentifier;

  static equals(a: LocationIdentifier | PlainMessage<LocationIdentifier> | undefined, b: LocationIdentifier | PlainMessage<LocationIdentifier> | undefined): boolean;
}

/**
 * Locations requirements when making a GDS search.
 *
 * @generated from message elude.proto.LocationsRequirements
 */
export declare class LocationsRequirements extends Message<LocationsRequirements> {
  /**
   * Location identifier data for departure.
   *
   * @generated from field: elude.proto.LocationIdentifier departure = 1;
   */
  departure?: LocationIdentifier;

  /**
   * Location identifiers for search destinations.
   *
   * @generated from field: repeated elude.proto.LocationIdentifier destinations = 2;
   */
  destinations: LocationIdentifier[];

  /**
   * Currently not used.
   *
   * @generated from field: repeated string blacklisted_cities = 3;
   */
  blacklistedCities: string[];

  constructor(data?: PartialMessage<LocationsRequirements>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.LocationsRequirements";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationsRequirements;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationsRequirements;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationsRequirements;

  static equals(a: LocationsRequirements | PlainMessage<LocationsRequirements> | undefined, b: LocationsRequirements | PlainMessage<LocationsRequirements> | undefined): boolean;
}

/**
 * Price quote is a fixed price from gds.
 *
 * @generated from message elude.proto.PriceQuote
 */
export declare class PriceQuote extends Message<PriceQuote> {
  /**
   * Price quote number.
   *
   * @generated from field: int32 identifier = 1;
   */
  identifier: number;

  constructor(data?: PartialMessage<PriceQuote>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.PriceQuote";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceQuote;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceQuote;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceQuote;

  static equals(a: PriceQuote | PlainMessage<PriceQuote> | undefined, b: PriceQuote | PlainMessage<PriceQuote> | undefined): boolean;
}

/**
 * Price of an Itinerary.
 *
 * @generated from message elude.proto.Price
 */
export declare class Price extends Message<Price> {
  /**
   * 3 letter currency code (eg, USD, EUR, HRK)
   *
   * @generated from field: string currency = 1;
   */
  currency: string;

  /**
   * Price amount after tax.
   *
   * @generated from field: float total = 2;
   */
  total: number;

  /**
   * Price amount before tax.
   *
   * @generated from field: float base = 3;
   */
  base: number;

  /**
   * Price amount after tax - Price amount before tax
   *
   * @generated from field: float tax = 4;
   */
  tax: number;

  /**
   * Total price * (percentage) + fixed fee
   *
   * @generated from field: float agent_fee = 5;
   */
  agentFee: number;

  /**
   * Base price - real price
   *
   * @generated from field: float base_price_difference = 6;
   */
  basePriceDifference: number;

  constructor(data?: PartialMessage<Price>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.Price";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Price;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Price;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Price;

  static equals(a: Price | PlainMessage<Price> | undefined, b: Price | PlainMessage<Price> | undefined): boolean;
}

/**
 * Contains information about a complete GDS itinerary.
 *
 * @generated from message elude.proto.GDSItinerary
 */
export declare class GDSItinerary extends Message<GDSItinerary> {
  /**
   * Itinerary flight data.
   *
   * @generated from field: elude.proto.FlightOption flight_option = 1;
   */
  flightOption?: FlightOption;

  /**
   * Itinerary hotel data.
   *
   * @generated from field: elude.proto.GDSHotel hotel = 2;
   */
  hotel?: GDSHotel;

  /**
   * Itinerary price data.
   *
   * @generated from field: elude.proto.Price price = 3;
   */
  price?: Price;

  /**
   * List of itinerary travellers data.
   *
   * @generated from field: repeated elude.proto.GDSTraveller travellers = 4;
   */
  travellers: GDSTraveller[];

  /**
   * Itinerary user.
   *
   * @generated from field: elude.proto.GDSUser user = 5;
   */
  user?: GDSUser;

  /**
   * Beginning and end trip dates.
   *
   * @generated from field: elude.proto.Dates dates = 6;
   */
  dates?: Dates;

  /**
   * Location identifier for departure trip location.
   *
   * @generated from field: elude.proto.LocationIdentifier departure_location = 7;
   */
  departureLocation?: LocationIdentifier;

  /**
   * Location identifier for destination trip location.
   *
   * @generated from field: elude.proto.LocationIdentifier destination_location = 8;
   */
  destinationLocation?: LocationIdentifier;

  /**
   * List of itinerary price quotes.
   *
   * @generated from field: repeated elude.proto.PriceQuote price_quotes = 9;
   */
  priceQuotes: PriceQuote[];

  constructor(data?: PartialMessage<GDSItinerary>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSItinerary";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSItinerary;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSItinerary;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSItinerary;

  static equals(a: GDSItinerary | PlainMessage<GDSItinerary> | undefined, b: GDSItinerary | PlainMessage<GDSItinerary> | undefined): boolean;
}

/**
 * Traveller message to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.GDSTraveller
 */
export declare class GDSTraveller extends Message<GDSTraveller> {
  /**
   * Traveller id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Traveller name.
   *
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * Travellers last name.
   *
   * @generated from field: string last_name = 3;
   */
  lastName: string;

  /**
   * Traveller date of birth (e.g. 2022-06-08).
   *
   * @generated from field: string date_of_birth = 4;
   */
  dateOfBirth: string;

  /**
   * Traveller email.
   *
   * @generated from field: string email = 6;
   */
  email: string;

  /**
   * Traveller title.
   *
   * @generated from field: string title = 7;
   */
  title: string;

  /**
   * Traveller type.
   *
   * @generated from field: string traveler_type = 8;
   */
  travelerType: string;

  constructor(data?: PartialMessage<GDSTraveller>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSTraveller";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSTraveller;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSTraveller;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSTraveller;

  static equals(a: GDSTraveller | PlainMessage<GDSTraveller> | undefined, b: GDSTraveller | PlainMessage<GDSTraveller> | undefined): boolean;
}

/**
 * User message to be used only in GDS rpc calls.
 *
 * @generated from message elude.proto.GDSUser
 */
export declare class GDSUser extends Message<GDSUser> {
  /**
   * User id.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * User first name.
   *
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * User last name.
   *
   * @generated from field: string last_name = 3;
   */
  lastName: string;

  /**
   * User date of birth (e.g. 2022-06-08).
   *
   * @generated from field: string date_of_birth = 4;
   */
  dateOfBirth: string;

  /**
   * User email.
   *
   * @generated from field: string email = 6;
   */
  email: string;

  /**
   * User phone number.
   *
   * @generated from field: string phone = 7;
   */
  phone: string;

  /**
   * User address.
   *
   * @generated from field: string address = 8;
   */
  address: string;

  /**
   * User title.
   *
   * @generated from field: string title = 9;
   */
  title: string;

  /**
   * User country code.
   *
   * @generated from field: string country_code = 10;
   */
  countryCode: string;

  /**
   * User country iso.
   *
   * @generated from field: string country_iso = 11;
   */
  countryIso: string;

  constructor(data?: PartialMessage<GDSUser>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.GDSUser";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GDSUser;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GDSUser;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GDSUser;

  static equals(a: GDSUser | PlainMessage<GDSUser> | undefined, b: GDSUser | PlainMessage<GDSUser> | undefined): boolean;
}

/**
 * Ticker info is used to track travellers ticket document numbers.
 *
 * @generated from message elude.proto.TicketInfo
 */
export declare class TicketInfo extends Message<TicketInfo> {
  /**
   * Traveller id.
   *
   * @generated from field: int32 traveller_id = 1;
   */
  travellerId: number;

  /**
   * Traveller ticket identifier.
   *
   * @generated from field: string document_number = 2;
   */
  documentNumber: string;

  constructor(data?: PartialMessage<TicketInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.TicketInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TicketInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TicketInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TicketInfo;

  static equals(a: TicketInfo | PlainMessage<TicketInfo> | undefined, b: TicketInfo | PlainMessage<TicketInfo> | undefined): boolean;
}

/**
 * Search location is used as basic location structure while searching other locations.
 *
 * @generated from message elude.proto.SearchLocation
 */
export declare class SearchLocation extends Message<SearchLocation> {
  /**
   * Location name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Location Description.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Location url built inside app with media path.
   *
   * @generated from field: string image_url = 3;
   */
  imageUrl: string;

  /**
   * Location iata code.
   *
   * @generated from field: string iata_code = 4;
   */
  iataCode: string;

  /**
   * Location type (metropolitan area/city/airport/region/country/location)
   *
   * @generated from field: elude.proto.LocationTypeEnum location_type = 5;
   */
  locationType: LocationTypeEnum;

  /**
   * Used for connected cities. Part of a city message.
   *
   * @generated from field: repeated elude.proto.Property properties = 6;
   */
  properties: Property[];

  /**
   * Every location can have multiple sub locations.
   *
   * @generated from field: repeated elude.proto.SearchLocation sublocations = 7;
   */
  sublocations: SearchLocation[];

  /**
   * Location iata code for the next connected city.
   *
   * @generated from field: string connected_city_iata_code = 8;
   */
  connectedCityIataCode: string;

  /**
   * Location id. Depends on Location type.
   *
   * @generated from field: int32 id = 9;
   */
  id: number;

  /**
   * Contains location data. Depends on location type.
   *
   * @generated from field: elude.proto.LocationMetadata metadata = 10;
   */
  metadata?: LocationMetadata;

  /**
   * If true than next connected locations exists. If false this is the last location in a row.
   *
   * @generated from field: bool connected_location = 11;
   */
  connectedLocation: boolean;

  /**
   * Median price for one night in a hotel
   *
   * @generated from field: int32 median_hotel_price = 12;
   */
  medianHotelPrice: number;

  /**
   * Id for shard location belongs to
   *
   * @generated from field: int32 shard_id = 13;
   */
  shardId: number;

  constructor(data?: PartialMessage<SearchLocation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "elude.proto.SearchLocation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchLocation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchLocation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchLocation;

  static equals(a: SearchLocation | PlainMessage<SearchLocation> | undefined, b: SearchLocation | PlainMessage<SearchLocation> | undefined): boolean;
}

